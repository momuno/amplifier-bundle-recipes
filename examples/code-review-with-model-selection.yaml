name: "code-review-with-model-selection"
description: "Code review demonstrating strategic model selection for cost/capability optimization"
version: "1.0.0"
author: "Amplifier Recipes Collection"
tags: ["code-review", "model-selection", "optimization", "example"]

# This recipe demonstrates MODEL SELECTION - using different models for different tasks.
#
# Model Selection Strategy:
# - claude-haiku: Fast, cheap - for simple classification, formatting, yes/no questions
# - claude-sonnet-*: Balanced - for code analysis, implementation, exploration
# - claude-opus-*: Powerful - for architecture, strategy, security, complex reasoning
#
# The glob pattern (e.g., claude-sonnet-*) automatically selects the latest version.
#
# Cost/Capability Tradeoffs:
# - Simple classification → haiku (fast, ~10x cheaper than opus)
# - Code analysis → sonnet (good balance of speed and capability)
# - Strategic design → opus (best reasoning, worth the extra cost)
#
# Usage:
#   amplifier run "execute code-review-with-model-selection.yaml with file_path=src/auth.py"

context:
  file_path: ""  # Required: path to file to review

steps:
  # Step 1: Quick structure scan
  # Model: haiku - just listing functions/classes, no deep analysis needed
  - id: "quick-scan"
    agent: "foundation:explorer"
    provider: "anthropic"
    model: "claude-haiku"
    prompt: |
      List the main components in {{file_path}}:
      - Function names with brief purpose
      - Class names with brief purpose
      - Key imports

      Keep it concise - just a structural overview.
    output: "structure"
    timeout: 120

  # Step 2: Deep code analysis
  # Model: sonnet - thorough analysis needs good reasoning but not the heaviest
  - id: "analyze-code"
    agent: "foundation:zen-architect"
    mode: "ANALYZE"
    provider: "anthropic"
    model: "claude-sonnet-*"
    prompt: |
      Based on this structure: {{structure}}

      Perform thorough code analysis on {{file_path}}:

      1. Code quality assessment
      2. Anti-patterns and code smells
      3. Complexity hotspots
      4. Potential bugs or edge cases
      5. Philosophy alignment (unnecessary abstraction, future-proofing)

      For each issue found:
      - Location (function/line)
      - Severity (critical/high/medium/low)
      - Explanation
    output: "analysis"
    timeout: 600

  # Step 3: Severity classification
  # Model: haiku - simple one-word classification, no reasoning needed
  - id: "classify-severity"
    agent: "foundation:zen-architect"
    provider: "anthropic"
    model: "claude-haiku"
    prompt: |
      Based on this analysis: {{analysis}}

      What is the OVERALL severity level?

      Respond with EXACTLY ONE WORD:
      - none (no issues, code is clean)
      - low (minor style/docs issues only)
      - medium (some issues but code works)
      - high (significant maintainability problems)
      - critical (bugs, security issues, major flaws)
    output: "severity"
    timeout: 60

  # Step 4: Quick approval path (for clean code)
  # Model: haiku - simple summary, no complex reasoning
  - id: "quick-approval"
    agent: "foundation:zen-architect"
    provider: "anthropic"
    model: "claude-haiku"
    condition: "{{severity}} == 'none'"
    prompt: |
      The code in {{file_path}} is clean with no significant issues.

      Provide a brief (3-4 sentence) approval summary:
      - Confirm quality assessment
      - Note any optional minor suggestions
      - Highlight patterns worth preserving
    output: "approval_summary"
    timeout: 60

  # Step 5: Design improvements (for code with issues)
  # Model: opus - strategic design decisions need the best reasoning
  - id: "design-improvements"
    agent: "foundation:zen-architect"
    mode: "ARCHITECT"
    provider: "anthropic"
    model: "claude-opus-*"
    condition: "{{severity}} != 'none'"
    prompt: |
      Based on this analysis: {{analysis}}
      Severity: {{severity}}

      Design concrete improvement recommendations for {{file_path}}:

      For each significant issue:
      1. Root cause analysis - why does this problem exist?
      2. Solution design - what's the simplest fix that addresses the root cause?
      3. Implementation approach - specific steps to implement
      4. Trade-offs - what are the costs/risks of this change?
      5. Priority - must-do / should-do / nice-to-have

      Focus on ruthless simplicity. Avoid over-engineering.
      Prioritize changes that genuinely improve maintainability.
    output: "improvements"
    timeout: 600

  # Step 6: Validate critical improvements
  # Model: opus - critical/high severity needs careful validation
  - id: "validate-improvements"
    agent: "foundation:zen-architect"
    mode: "REVIEW"
    provider: "anthropic"
    model: "claude-opus-*"
    condition: "{{severity}} == 'critical' or {{severity}} == 'high'"
    prompt: |
      Review these improvement suggestions: {{improvements}}

      For the file: {{file_path}}
      With severity: {{severity}}

      This is {{severity}}-severity, so thorough validation is critical.

      For each suggestion:
      1. Feasibility - can this be implemented safely?
      2. Value - does this genuinely improve the code?
      3. Scope - is this the right level of change?
      4. Risks - what could go wrong?

      Provide:
      - Final priority ranking
      - Implementation order (dependencies)
      - Time estimates
      - Suggestions to drop (not worth the effort)

      Be honest about what's truly valuable vs what's just "different".
    output: "validated_improvements"
    timeout: 300

# Model Selection Summary:
#
# Step                    | Model         | Why
# ----------------------- | ------------- | -------------------------------------------
# quick-scan              | haiku         | Simple listing, no reasoning needed
# analyze-code            | sonnet-*      | Thorough analysis, balanced capability
# classify-severity       | haiku         | One-word classification, trivial task
# quick-approval          | haiku         | Brief summary, no complex reasoning
# design-improvements     | opus-*        | Strategic design needs best reasoning
# validate-improvements   | opus-*        | Critical validation needs best reasoning
#
# Cost optimization: haiku steps are ~10x cheaper than opus
# Capability matching: opus reserved for strategic/critical decisions
